# V8

一步步来，系统学习前端架构知识，同时慢慢积累科班计算机基础课，如：数据结构与算法，操作系统，计算机网络，编译原理等。

## 前言

**通过学习V8的工作机制来分析JavaScript的底层机制**

Chrome中的JavaScript引擎——V8，V8 是 JavaScript **虚拟机的一种**。虚拟机即为一个将高级编程语言转为机器语言的**程序**。



市面上的JavaScript引擎有：

- SiderMonkey
- V8
- JavaScriptCore
- ...

V8 之前，所有的 JavaScript 虚拟机所采用的都是**解释执行**的方式，特点就是**执行速度慢**。

V8 率先引入了**即时编译（JIT）**策略，混合**编译执行和解释执行**这两种手段，极大提升了JavaScript 的执行速度。V8 也是早于其他虚拟机引入了**惰性编译**、**内联缓存**、**隐藏类**等机制，进一步优化了 JavaScript 代码的编译执行效率。

### 为什么学习V8？

- 解决开发中的问题，如占用内存过高，页 面响应速度过慢，使用 Node.js 的时候导致任务被阻塞等
- 深入理解JavaScript这门语言的特性，本质和设计思想
- 面试

###  JavaScript 语言本质和设计思想

V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它。即V8会实现JavaScript语言在设计时确立下来的特性和功能。

JavaScript借鉴了很多语言的特性：

- C 语言的基本语法
- Java 的类型系统和内存管理（垃圾回收）
- Scheme 的函数作为一等公民
  - 函数拥有普通类型的特性
    - 可以参数
    - 可以作为返回值
    - 可以赋值给一个变量
  - JavaScript 采取了基于对象的策略
- Self 基于原型（prototype）的继承机制
  - 为了实现原型继承，V8 为每个对象引入了` __proto__ `属性



JavaScript中的坑（举例）：

- 使用 new 加构造函数来创建对象，这种方式的背后隐藏了太多的细 节，非常容易增加代码出错概率
- 初期的 JavaScript 没有块级作用域机制，导致变量提升



学习V8工作原理时，关注 JavaScript 的特性，设计思想和特性背后的V8是怎么实现该特性的，比如，为了实现函数是一等公民的特性，JavaScript 采 取了基于对象的策略； 为了实现原型继承，V8 为每个对象引入了 `__proto__ `属性。分析过JavaScript语言之后，再学习V8执行JavaScript代码的完整流程。

### V8编译流水线

V8 执行 JavaScript 代码的完整流程称之为 V8 的编译流水线

![image-20220806195103725](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220806195103725.png)

其中涉及的技术如 JIT、延迟解析、隐藏类、内联缓存等。

V8中使用隐藏类是将 JavaScript 中动态类型转换为静态类型 的一种技术，可以消除动态类型的语言执行速度过慢的问题，开发者在编写JavaScript代码时，可以充分利用好隐藏类这种强大的优化特性，写出更加高效的代码。

V8 实现了 JavaScript 代码的惰性解析，是为了加速代码的启动速度，可以优化JavaScript代码更加适应这个机制，从而提高程序性能。



### 事件循环系统

事件循环系统和异步编程特性高度相关。JavaScript是单线程的，如果同一时间需要做多件任务，那这些任务就需要被管理起来有序执行，而V8的事件循环系统就是负责调度这些任务的，它驱动了 V8 的持续工作。



### 垃圾回收机制

JavaScript 是一种自动垃圾回收的语言。V8 在执行垃圾回收时，会占用主线程的资 源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程。需要知道 V8 是如何分配内存数据的，这些数据是如何被回收的。





### JavaScript的特征

- 函数是一等公民
- 类型系统
- 垃圾回收
- 静态作用域
- 原型链继承

JavaScript 的设计思想和特征，V8 是怎么实现这些特性。



## 宏观视角下的V8

宏观上认识一下V8，以及 V8 是怎么执行一段 JavaScript 代码。

V8 是 JavaScript 虚拟机的一种。虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 CPU、堆栈、寄存器等，虚拟机还具有它**自己的一套指令系统**。

当 V8 执行 JavaScript 代码时， 不需要担心不同操作系统的差异，不需要担心不同体系结构计算机的差异，只需要按照虚拟机的规范写好代码就可以。



V8执行JavaScript的核心流程：

- 编译：将 JavaScript 代码转换为中间代码（字节码）或者机器能够理解的机器代码
- 执行：执行转换后的代码并输出执行结果



渲染进程和Javascript引擎之间的关系：每个渲染进程都有一个JavaScript引擎，渲染进程是JavaScript引擎的宿主环境。

v8执行js代码时，内存区域有堆内存中的新生代和老生代，字节码区，机器码区和栈区。



### 高级语言为什么需要先编译再执行？

#### CPU执行机器代码的过程

CPU是一个运算机器，开发者可以通过二进制的指令和 CPU 进行沟通，比如给 CPU 发出“1000100111011000”（长度为两个字节）的二进制指令，这条指令的意思是将一个寄存器中的数据移动 到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。

为了能够完成复杂的任务，工程师们为 CPU 提供了一大堆指令，来实现各种功能，把这一大堆指令称为**指令集**（Instructions），也就是**机器语言**。

CPU 只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集

```
1000100111011000 机器指令
mov ax,bx 汇编指令
```

CPU也不能直接识别汇编代码，汇编语言写的程序也需要使用汇编编译器将汇编代码转为机器代码来执行。



书写机器代码和或者汇编代码的不实际性：

- 语法难以记忆

- 不同的 CPU 有着不同的指令集

- 汇编语言依然是复杂且繁琐

  > 如果要使用机器语言或者汇编语言来实现一个功 能，那么你需要为每种架构的 CPU 编写特定的机器代码或者汇编代码，这会带来巨大的、枯燥繁琐的操作

![image-20220806212800738](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220806212800738.png)

- 在编写汇编代码时，还需要了解和处理器架构相关的硬件知识，比如需要使用寄存器、内存、操作 CPU 等。

  

由于以上的原因，就产生了高级语言，它们是屏蔽了计算机架构细节的语言，能适应多种不同CPU 架构。

高级语言有两种不同的处理方式：

- 解释执行：先将输入的源代码通过**解析器**编译成中间代码，之后直接使用**解释器**解释执行中间代码，然后直接输出结果。（启动速度快，但是执行时的速度慢）

- 编译执行：先将源代码由**解析器**转换为中间代码，**编译器**再将中间代码编译成机器代码（编译执行的启动速度慢，但是执行时的速度快）。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以。或者可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

  

解释型语言的执行速度慢的原因有：

- 执行之前需要先进行编译（所以比编译型语言多了一个编译的姐阶段）
- 大部分解释型的语言都是动态语言，动态语言的数据类型是在运行时检查的，这也需要耗时



#### V8执行JavaScript代码的流程

**V8执行JavaScript代码时，并没有采用某种单一的技术，而是混合编译执行和解释执行这两种。**把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。

**V8在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。**

V8 执行 JavaScript 的流程图：

![image-20220806213910946](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220806213910946.png)

从左往右看，在 V8 启动执行 JavaScript 之前，它还需要**准备执行 JavaScript 时所需要的一些基础环境**，这些基础环境包括了

- 堆空间
- 栈空间
- 全局执行上下文
- 全局作用域（全局变量）
- 事件循环系统，消息队列
- 内置函数
- ...

这些内容都是在执行JavaScript 过程中需要使用到的。

基础环境准备后，就可以向 V8 提交要执行的 JavaScript 代码了。

1. v8接受JavaScript源码，但不能直接识别JavaScript源码

2. 结构化源码生产AST,同时生成相关的作用域，用于存放变量，包括作用域链指向

   > 结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。

3. 基于AST生成字节码

   > 字节码是介于 AST 和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。

4. 解释器解释执行生成的字节码，并输出执行结果

5. 在解释器执行的过程中，有一个模块会监控解释器执行状态，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控模块会将这段代码标记为热点代码。

6. 当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在 后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二 进制机器代码的执行效率会得到大幅提升。

7. 如果后面再执行到这段代码时，那么 V8 会优先 选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。



> 和静态语言不同的是，JavaScript 是一种非常灵活的动态语言，对象的结构和属性 是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一 旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。



#### V8 执行一段 JavaScript 代码的主要流程

1. 初始化基础环境；
2. 解析源码生成 AST 和作用域； 
3. 依据 AST 和作用域生成字节码；
4. 解释执行字节码； 
5. 监听热点代码； 
6. 优化热点代码为二进制的机器代码； 
7. 反优化生成的二进制机器代码。

V8 是一门动态语言，在运行过程中，某些被优化的结构可能会被 JavaScript 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效 了，那么编译器需要执行反优化操作。



#### 跟踪一段实际代码的执行流程

test.js:

```js
var test = 'GeekTime'
```

要查看 V8 中间生成的一些结构，可以使用 V8 提供的调试工具 D8 来查看。

```
d8 --print-ast test.js
```

AST:

```
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 11
. . . INIT at 11
. . . . VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
. . . . LITERAL "GeekTime"
```

![image-20220809075559088](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809075559088.png)



作用域:

```
d8 --print-scopes test.js
```



```
Global scope:
global { // (0x7fd974022048) (0, 24)
    // will be compiled
    // 1 stack slots
    // temporary vars:
    TEMPORARY .result; // (0x7fd9740223c8) local[0]
    // local vars:
    VAR test; // (0x7fd974022298)
}
```



字节码：

```
d8 --print-bytecode test.js
```



```
[generated bytecode for function: (0x2b510824fd55 <SharedFunctionInfo>)]
Parameter count 1
Register count 4
Frame size 32
0x2b510824fdd2 @ 0 : a7 StackCheck
0x2b510824fdd3 @ 1 : 12 00 LdaConstant [0]
0x2b510824fdd5 @ 3 : 26 fa Star r1
0x2b510824fdd7 @ 5 : 0b LdaZero
0x2b510824fdd8 @ 6 : 26 f9 Star r2
0x2b510824fdda @ 8 : 27 fe f8 Mov <closure>, r3
0x2b510824fddd @ 11 : 61 32 01 fa 03 CallRuntime [DeclareGlobals]
0x2b510824fde2 @ 16 : 12 01 LdaConstant [1]
0x2b510824fde4 @ 18 : 15 02 02 StaGlobal [2], [2]
0x2b510824fde7 @ 21 : 0d LdaUndefined
0x2b510824fde8 @ 22 : ab Return
Constant pool (size = 3)
0x2b510824fd9d: [FixedArray] in OldSpace
- map: 0x2b51080404b1 <Map>
- length: 3
0: 0x2b510824fd7d <FixedArray[4]>
1: 0x2b510824fd1d <String[#8]: GeekTime>
2: 0x2b51081c8549 <String[#4]: test>
Handler Table (size = 0)
Source Position Table (size = 0)
```



查看被编译优化的代码：

```
d8 --trace-opt test.js
```



查看被反优化的代码：

```
pt --trace-deopt test.js
```





## 函数

**如果某个编程语言的函数可以和其他数据类型做一样的事情，就把这个语言中的函数称为一等公民。**

### JavaScript中函数的特点

 JavaScript 中的函数就是一种特殊的对象。它和对象一样可以拥有属性和值，但是函数和普通对象不同的是，函数可以被调用。

基于函数是一等公民的设计，使得 JavaScript 非常容易实现一些特性，比如闭包，还有函数式编程等，其他语言在实现这些特征时就比较困难。



JavaScript 是一门**基于对象** (Object-Based) 的语言，而不是**面向对象**，对象在运行时可以动态修改其内容。但是它却不是一门面向对象的语言 (ObjectOriented Programming Language)，因为面向对象语言天生支持封装、继承、多态，JavaScript没有直接提供对多态的支持。

JavaScript 实现继承的方式和面向对象的语言实现继承的方式同 样存在很大的差异。面向对象语言是由语言本身对继承做了充分的支持，并提供了大量的关键字，如 public、 protected、friend、interface 等。

什么是 JavaScript 中的“对象”？它和面向对象语言中的“对象”有什么区别？

JavaScript 中的对象就是由一组组属性和值构成的集合，对象的值可以是任意类型的数据。



### V8 内部是怎么实现函数可调用特性？

在 V8 内部会为函数对象添加了两个隐藏属性，具体属性如下图所示：

![image-20220807114610141](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807114610141.png)

函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性，分别是 name 属性和 code 属性。

隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，该函数对象的默认的 name 属性值就是 anonymous，表示该函数对象没有被设置名称。

隐藏属性 code 属性，其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码。



### 函数带来的特性

闭包（将外部变量和和函数绑定起来的技术）。在执行 JavaScript 函数的过程中，为了实现变量的查找，V8 会为其维护一个作用域链，如果函数中使用了某个变量，但是在函数内部又没有定义该变量，那么函数就会沿 着作用域链去外部的作用域中查找该变量，具体流程如下图所示：

![image-20220809080944228](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809080944228.png)

实现闭包就虚拟机需要处理函数引用的外部变量。





## 内存快照

在 Chrome 中查看内存快照。

在控制台运行这样一段程序：

```js
function Food(name, type) {
  this.name = name;
  this.type = type;
}
var beef = new Food('beef', 'meat');
```

切换到 Memory 中，点击左侧的小圈圈就可以捕获当前的内存快照。

![image-20220807184618777](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807184618777.png)

通过构造函数创建对象，主要是为了更方便地在快照中找到它。

![image-20220807184646491](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807184646491.png)



## 对象属性

V8 实现对象存储时，并**没有完全**采用字典的存储方式，主要是出于性能的考量。 因为字典是非线性的数据结构，**查询效率**会低于线性的数据结构，V8 为了提升对象的属性的存储和查找效率，采用了一套复杂的存储策略。非线性的数据结构的**修改和删除效率高**。

![image-20220807121555590](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807121555590.png)

V8 采用了哪些策略提升了对象属性的访问速度？



### V8 中对象的结构

在 V8 中，对象主要由三个指针构成，分别是隐藏类（Hidden Class），`Property` 还有 `Element`。

![image-20220807184859439](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807184859439.png)







#### 常规属性 (properties) 和排序属性 (element)

```js
function Foo() {
    this[100] = 'test-100'
    this[1] = 'test-1'
    this["B"] = 'bar-B'
    this[50] = 'test-50'
    this[9] = 'test-9'
    this[8] = 'test-8'
    this[3] = 'test-3'
    this[5] = 'test-5'
    this["A"] = 'bar-A'
    this["C"] = 'bar-C'
    this[Symbol('foo')] = 'symbol-1'  // symbol属性默认是无法被for in 循环取到的。
}
var bar = new Foo()
for(key in bar){
    console.log(`index:${key} value:${bar[key]}`)
}

// index:1 value:test-1
// index:3 value:test-3
// index:5 value:test-5
// index:8 value:test-8
// index:9 value:test-9
// index:50 value:test-50
// index:100 value:test-100
// index:B value:bar-B
// index:A value:bar-A
// index:C value:bar-C
```

结论：

- 设置的数字属性被最先打印出来了，并且按照数字大小的顺序打印的；
- 设置的字符串属性依然是按照之前的设置顺序打印的；

之所以出现这样的结果，是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大 小升序排列，字符串属性根据创建时的顺序升序排列。**

**把对象中的数字属性称为排序属性**，在 V8 中被称为 **elements**

**字符串属性就被称为常规属性**，在 V8 中被称为 **properties**。

在 V8 内部，为了有效地提升**存储和访问**这两种属性的性能，分别使用了**两个线性数据结构**来分别保存排序属性和常规属性，具体结构如下图所示：

![image-20220807120401915](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807120401915.png)

bar 对象包含了两个隐藏属性：elements 属性和 properties 属 性，elements 属性指向了 **elements 对象**，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 **properties 对象**，在 properties 对象中，会**按照创建时的顺序保存**常规属性。

**分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按 照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。**



### 快属性和慢属性

将不同的属性分别保存到 elements 属性和 properties 属性中，能简化程序的复杂 度，但是在查找元素时，却多了一步操作。比如执行 bar.B这个语句来查找 B 的属性值， 那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。

基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为**对象内属性 (in-object properties)**。对象在内存中的展现形式参考下图：



![image-20220807122032030](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807122032030.png)



采用对象内属性之后，常规属性就被保存到 bar 对象本身了，这样当再次使用bar.B来查 找 B 的属性值时，V8 就可以直接从 bar 对象本身去获取该值就可以了，这种方式减少查找 属性值的步骤，增加了查找效率。

不过对象内属性的数量是固定的，默认是 10 个，如果添加的属性超出了对象分配的空间， 则超出的那些属性将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。

将保存在线性数据结构中的属性称之为“快属性”。线性数据结构中只需要 通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。

因此，如果一个对象的属性过多时，V8 为就会采取另外一种存储策略，那就是“慢属性”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。

![image-20220807183252644](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807183252644.png)



**如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线 性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改 对象的属性的速度。**

```js
function Foo(property_num,element_num) {
    //添加可索引属性
    for (let i = 0; i < element_num; i++) {
        this[i] = `element${i}`
    }
    //添加常规属性
    for (let i = 0; i < property_num; i++) {
        let ppt = `property${i}`
        this[ppt] = ppt
    }
    
     for (let i = 0; i < property_num; i++) {
        let ppt = `property${i}`
        this[Symbol(ppt)] = ppt
    }
}
var bar = new Foo(20,10)
```

通常不建议使用 delete 来删除属性的原因？



## 函数表达式

使用函数表达式可以实现代码隐藏和变量隔离，在开源项目中很常见。

重点在于理解表达式和语句。

函数表达式和函数声明：

![image-20220807190313756](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220807190313756.png)

函数表达式和函数声明有着本质上的差异。

两种定义函数的方式具有不同语义，不同的语义触发了不同的行为。

### V8处理函数声明

在**编译阶段**，如果解析到函数声明，那么 V8 会将这个函数声明转换为堆内存中的函数对象， 并将其内存地址指针放到作用域中。 如果解析到了某个变量声明，也会将其放到作用域中，但是会将其值设置为 undefined，表示该变量还未被使用。

```js
var x = 5
function foo(){
    console.log('Foo')
}
```

在执行阶段，如果使用了某个变量，或者调用了某个函数，那么 V8 便会去作用域查找相关内容。

![image-20220809122949514](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809122949514.png)

D8查看作用域的数据：

```
Global scope:
global { // (0x7fb62281ca48) (0, 50)
    // will be compiled
    // 1 stack slots
    // temporary vars:
    TEMPORARY .result; // (0x7fb62281cfe8) local[0]
    // local vars:
    VAR x; // (0x7fb62281cc98)
    VAR foo; // (0x7fb62281cf40)
    function foo () { // (0x7fb62281cd50) (22, 50)
        // lazily parsed
        // 2 heap slots
    }
}
```

函数对象被 V8 存放在内存中的堆空间了，这些变量都是在编译阶段被装进作用域中的。因为在执行之前，这些变量都被提升到作用域中了，所以在执行阶段，V8 当然就能获取到所有的定义变量。



### 表达式和语句

```js
x = 5   // 该语句返回5
```

表达式就是表示值的式子，而语句是操作值的式子。

对于函数声明式的写法，它是语句而不是表达式。

**在变量提升阶段，V8 并不会执行赋值的表达式，该阶段只会分析基础的语句，比如变量的定义，函数的声明。**

在 V8 解析 JavaScript 源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作用域中，并给该变量赋值为 undefined，如果遇到的是函数声明，那么 V8 会在内存中为声明生成函数对象，并将该对象提升到作用域中。

![image-20220809132615191](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809132615191.png)

在 V8 执行var x = 5这段代码时，会认为它是两段代码，一段是定义变量的语句，一段是赋值的表达式，如下所示：

```js
var x = undefined
x = 5
```

**所有的表达式都是在执行阶段完成的。**



### IIFE

**在编译阶段，V8 并不会处理函数表达式，而 JavaScript 中的立即函数调用表达式正是使用了这个特性来实现了非常广泛的应用**。

**JavaScript 中有一个圆括号运算符，圆括号里面可以放一个表达式**，比如下面的代码：

```
(a=3)
```

**括号里面是一个表达式，整个语句也是一个表达式，最终输出 3。**

```js
(function () {
	//statements
})
```

因为小括号之间存放的必须是表达式，所以如果在小阔号里面定义一个函数，那么 V8 就会把这个函数看成是函数表达式，执行时它会返回一个函数对象。

存放在括号里面的函数便是一个函数表达式，它会返回一个函数对象，如果我直接在表达式 后面加上调用的括号，这就称立即调用函数表达式（IIFE），比如下面代码：

```js
(function () {
	//statements
})()
```

**因为函数立即表达式也是一个表达式，所以 V8 在编译阶段，并不会为该表达式创建函数对象。这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到。**

使用函数立即表达式就可以将我们内部变量封装起来， 避免了相互之间的变量污染。

因为函数立即表达式是立即执行的，所以将一个函数立即表达式赋给一个变量时，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。

**函数声明的本质是语句，而函数表达式的本质则是表达式。**



## 原型链

**继承就是一个对象可以访问另外一个对象中的属性和方法。**

不同的语言实现继承的方式是不同的，其中最典型的两种方式是**基于类的设计**和**基于原型继承的设计**。



基于类的设计模式最大的特点就是提 供了非常复杂的规则，并提供了非常多的关键字，诸如 class、friend、protected、 private、interface 等，通过组合使用这些关键字，就可以实现继承。使用基于类的继承时，如果业务复杂，那么你需要创建大量的对象，然后需要维护非常复杂 的继承关系，这会导致代码过度复杂和臃肿，另外引入了这么多关键字也给设计带来了更大 的复杂度。



JavaScript 本身不提 供一个 class 实现，虽然标准委员会在 ES2015/ES6 中引入了 class 关键字，但那只是语法 糖，JavaScript 的继承依然和基于类的继承没有一点关系。



基于原型继承是如何实现？

`JavaScript 的每个对象都包含了一个隐藏属性 __proto__ ，把该隐藏属性 __proto__ 称之为该对象的原型 (prototype)，__proto__ 指向了内存中的另外一个对象，把 __proto__ 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。`

作用域链是沿着函数的作用域 一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的。



通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代 浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性` _proto_`，但是在实际项目中， 我们不应该直接通过` _proto_ `来访问或者修改该属性，其主要原因有两个：

- 这是隐藏属性，并不是标准定义的
- 使用该属性会造成严重的性能问题



### 构造函数创建对象

```js
function DogFactory(type,color){
    this.type = type
    this.color = color
}

var dog = new DogFactory('Dog','Black')

```

当 V8 执行上面这段代码时，V8 会在背后悄悄地做了以下几件事情，模拟代码如下所 示：

```js
var dog = {}  // 创建了一个空白对象 dog
dog.__proto__ = DogFactory.prototype  // 将 DogFactory 的 prototype 属性设置为 dog 的原型对象
DogFactory.call(dog,'Dog','Black')  // 再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 等于对象 dog 执行属性填充操作，最终就创建了对象dog。
```



每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一 个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性。





## 作用域链

原型链将一个个原型对象串起来， 从而实现对象属性的查找。

作用域链就是将一个个作用域串起来，实现变量或者方法的查找路径。讨论作用域链，实际就是在讨 论按照什么路径查找变量的问题。



### 作用域的工作原理

在 V8 执行函数时，会在编译阶段为函数创建一个作用域。函数中定义的变量和声明的函数都会丢到该作用域中，另外系统还为函数作用域添加了另外一个隐藏变量 this。

在执行一 个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域中 查找相关内容。



全局作用域是**在 V8 启动过程中就创建**了，且一直保存在内存中不会被销毁的，直至 V8 退出。 而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

V8 启动之后就进入正常的消息循环状态，执行代码。

JavaScript 是基于词法作用域的，词法作用域就是指，查找作用域的顺序是按照函数 定义时的位置来决定的。

因为词法作用域是根据函数在代码中的位置来确定的，作用域是在 声明函数时就确定好的了，所以我们也将词法作用域称为静态作用域。

和静态作用域相对的是动态作用域，动态作用域并不关心函数和作用域是如何声明以及在何 处声明的，只关心它们从何处调用。换句话说，动态作用域的作用域链是基于调用栈的，而不是基于函数定义的位置的。



**function f(){setTimeOut(f,0)}这种调用会不会导致内存溢出？**

> 不会溢出啊，因为这是异步调用，下次执行f函数时，已经在新的栈中执行 了，所以当前栈不会发生溢出！  
>
> 理解这个问题核心是理解事件循环和消息队列这套机制

**在大量数据时(百万级别) ，foreach循环比for循环的执行效率低，是因为什么？**





## 类型系统

V8如何实现1 + ‘2’ ？

对机器语言来说，所有的数据都是一堆二进制代码，CPU 处理这些数据的时候，并没有类型的概念，CPU 所做的仅仅是移动数据，比如对其进行移位，相加或相乘。

在高级语言中，都会为操作的数据赋予指定的类型。引入了这些类型之后，编译器或者解释器就可以根据类型来限制一些有害的或者没有意义的操作。

每种语言都定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用，我们就把这称为类型系统。

一门语言的类型系统定义了各种类型之间应该如何相互操作，比如，两种不同 类型相加应该如何处理，两种相同的类型相加又应该如何处理等。还规定了各种不同类型应 该如何相互转换，比如字符串类型如何转换为数字类型。



当有两个值相加的时候，V8 会严格根据 ECMAScript 规范来执行操作。比如在 ECMAScript 就定义了怎么执行加法操作，如下所 示：

![image-20220809220401517](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809220401517.png)



1. 把第一个表达式 (AdditiveExpression) 的值赋值给左引用 (lref)。 

2. 使用 GetValue(lref) 获取左引用 (lref) 的计算结果，并赋值给左值。 

3. 使用ReturnIfAbrupt(lval) 如果报错就返回错误。

4. 把第二个表达式 (MultiplicativeExpression) 的值赋值给右引用 (rref)。

5. 使用 GetValue(rref) 获取右引用 (rref) 的计算结果，并赋值给 rval。

6. 使用ReturnIfAbrupt(rval) 如果报错就返回错误。

7. 使用 ToPrimitive(lval) 获取左值 (lval) 的计算结果，并将其赋值给左原生值 (lprim)。

8. 使用 ToPrimitive(rval) 获取右值 (rval) 的计算结果，并将其赋值给右原生值 (rprim)。

9. **如果 Type(lprim) 和 Type(rprim) 中有一个是 String，则：**

   1. **把 ToString(lprim) 的结果赋给左字符串 (lstr)；**
   2. **把 ToString(rprim) 的结果赋给右字符串 (rstr)；**
   3. **返回左字符串 (lstr) 和右字符串 (rstr) 拼接的字符串。**

10. **把 ToNumber(lprim) 的结果赋给左数字 (lnum)。**

11. **把 ToNumber(rprim) 的结果赋给右数字 (rnum)。**

12. 返回左数字 (lnum) 和右数字 (rnum) 相加的数值。

    

通俗地理解，V8 会提供了一个 ToPrimitve 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进 行强制类型转换；
2. 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值；
3. 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的 错误。

将对象转换为原生类型的流程图如下所示：

![image-20220809220804644](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809220804644.png)

当 V8 执行 1+“2”时，因为这是两个原始值相加，原始值相加的时候，如果其中一项是字符串，那么 V8 会默认将另外一个值也转换为字符串，相当于执行了下面的操作：

```js
Number(1).toString() + "2"
```

把数字 1 偷偷转换为字符串“1”的过程也称为强制类型转换，因为这种转换是隐式的，所以如果我们不熟悉语义，那么就很容易判断错误。

```js
var Obj = {
    toString() {
        return '200'
    },
    valueOf() {
        return 100
    }
}
Obj+3
```

上面我们介绍过了，由于需要先使用 ToPrimitve 方法将 Obj 转换为原生类型，而 ToPrimitve 会优调用对象中的 valueOf 方法，由于 valueOf 返回了 100，那么 Obj 就会 被转换为数字 100，那么数字 100 加数字 3，那么结果是 103 。

如果我改造下代码，让 valueOf 方法和 toString 方法都返回对象，其改造后的代码如下：

```js
var Obj = {
    toString() {
        return new Object()
    },
    valueOf() {
        return new Object()
    }
}
Obj+3
```

因为 ToPrimitve 会先调用 valueOf 方法，发现返回的是一个对象，并不是原生类型，当 ToPrimitve 继续调用 toString 方法时，发现 toString 返回的也是一个对象，都是对象， 就无法执行相加运算了，这时候虚拟机就会抛出一个异常，异常如下所示：

```js
VM263:9 Uncaught TypeError: Cannot convert object to primitive value at <anonymous>:9:6
```

提示的是类型错误，错误原因是无法将对象类型转换为原生类型。



在执行加法操作的时候，V8 会通过 ToPrimitve 方法将对象类型转换为原生类 型，最后就是两个原生类型相加，如果其中一个值的类型是字符串时，则另一个值也需要强 制转换为字符串，然后做字符串的连接运算。在其他情况时，所有的值都会转换为数字类型 值，然后做数字的相加。



## V8的调试工具d8

可以使用 d8 来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优 化的二进制代码、垃圾回收的状态，还可以使用 d8 提供的私有 API 查看一些内部信息。

### 通过 V8 的源码构建 D8

通常，没有直接获取 d8 的途径，而是需要通过编译 V8 的源码来生成 d8。

1. 载 V8 的源码
2. 生成工程文件
3. 编译 V8 的工程并生成 d8



V8 并不是一个单一的版本库，它还引用了很多第三方的版本库，大多是版本库我们都无法直接访问，所以，在下载代码过程中，先准备一个 VPN。

下载编译工具链：depot_tools，后续 V8 源码的下载、配置和编译都是由 depot_tools 来完成的。

depot_tools 压缩包下载到本地之后，解压压缩包，然后需要将解压路径添加到环境变量中，这样我们就可以在控制台中使用 gclient 。



设置环境变量，还需要往系统环境变量中添加变量 DEPOT_TOOLS_WIN_TOOLCHAIN ，值设为0。

这个环境变量的作用是告诉 deppt_tools，使用本地已安装的默认的 Visual Studio 版本去编译，否则 depot_tools 会使用 Google 内部默认的版本。



安装 VS2019，在 Windows 系统下面，depot_tools 使用了 VS2019，因为 VS2019 自带了编译 V8 的编
译器，所以需要安装 VS2019 时，安装时，你需要选择以下两项内容：

```
Desktop development with C++；
MFC/ATL support
```

因为编译 V8 时，使用了这两项所提供的基础开发环境。



下载 V8 源码，使用 depot_tools 来下载 V8 源码，具体下载命令如下所示：这个过程比较耗时

```
d:
mkdir v8
cd v8
fetch v8
cd v8
```

![image-20220814112152417](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814112152417.png)



配置工程，代码下载完成之后，就需要配置工程了，我们使用 gn 来配置。

```
cd v8

// windows
gn gen out.gn/x64.release --args='is_debug=false target_cpu="x64" v8_target_cpu="arm64" use_goma=true'


// mac
gn gen out/gn --ide=xcode
```

gn 是一个跨平台的构建系统，用来构建 Ninja 工程，Ninja 是一个跨平台的编译系统，比如可以通过 gn 构建 Chromium 还有 V8 的工程文件，然后使用 Ninja 来执行编译，可以使用 gn 和 Ninja 来配合使用构建跨平台的工程，这些工程可以在 macOS、Linux、Windows 等平台上进行编译。在 gn 之前，Google 使用了 gyp 来构建，由于 gn 的效率更高，所以现在都在使用 gn。



生成 V8 工程的一些基础配置项：

- is_debug = false 编译成 release 版本 ;
- is_component_build = true 编译成动态链接库而不是很大的可执行文件 ;
- symbol_level = 0 将所有的 debug 符号放在一起，可以加速二次编译，并加速链接过
  程 ;
- ide = vs2019 ide=xcode。



工程生成好之后，你就可以去 v8\out.gn\x64.release 这个目录下查看生成的工程文件。如下图所示：

![image-20220814112602812](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814112602812.png)



生成了 d8 的工程配置文件，接下来就可以编译 d8 了，你可以使用下面的命令：

```
ninja -C out.gn/x64.release
```

如果想编译特定目标，比如 d8，可以使用下面的命令：

```
ninja -C out.gn/x64.release d8
```

这个命令只会编译和 d8 所依赖的工程，然后就开始执行编译流程了。如下图所示：

![image-20220814112724346](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814112724346.png)

编译时间取决于你硬盘读写速度和 CPU 的个数。最终编译结束之后，你就可以去 v8\out.gn\x64.release 查看生成的文件，如下图所示：

![image-20220814112811727](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814112811727.png)





### 使用 d8

现在我们编译出来了 d8 ，接下来我们将 d8 所在的目录，v8\out.gn\x64.release添加到环境变量“PATH”的路径中，这样我们就可以在控制台中使用 d8了。

测试下能不能使用 d8，你可以使用下面这个命令，在控制台中执行 d8：

```
d8 --help
```

![image-20220814112933069](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814112933069.png)

d8 --help 打印出来的列表非常长，如果过滤特定的命令，你可以使用下面的命令来查看：

```
d8 --help |grep print
```

查看看 d8 有多少关于 print 的命令，如果使用了 Windows 系统，可能缺少 grep 程序，你可以去下载。

安装完成之后，记得手动将 grep 程序所在的目录添加到环境变量 PATH 中，这样才能在控制台使用 grep 命令。

最终打印出来带有 print 字样的命令，包含以下内容：

![image-20220814113328053](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814113328053.png)



每一行其实都对应着一个命令，比如 print-bytecode 就是查看生成的字节码，print-opt-code 是要查看优化后的代码，turbofan-stats 是打印出来优化编译器的一些统计数据的命令，每个命令后面都有一个括号，括号里面是介绍这个命令的具体用途。

使用 d8 进行调试方式如下：

```
d8 test.js --print-bytecode
```

d8 后面跟上文件名和要执行的命令，如果执行上面这行命令，就会打印出 test.js 文件所生成的字节码。

一些重点的命令，比如 trace-gc，trace-opt-verbose，涉及到了编译流水线的中间数据，垃圾回收器执行状态。熟悉使用这些命令可以帮助我们更加深刻理解编译流水线和垃圾回收器的执行状态。

在使用 d8 执行一段代码之前，你需要将你的 JavaScript 源码保存到一个 js 文件中，把所需要需要观察的代码都存放到 test.js 这个文件中。

- –print-ast 来查看中间生成的 AST
- -print-scope 来查看中间生成的作用域
- –print-bytecode 来查看中间生成的字节码



### D8查看代码优化

通过D8查看V8对JavaScript代码的优化：

```js
let a = {x:1}
function bar(obj) {
return obj.x
}
function foo () {
let ret = 0
for(let i = 1; i < 7049; i++) {
ret += bar(a)
}
return ret
}
foo()
```

当 V8 先执行到这段代码的时候，监控到 while 循环会一直被执行，于是判断这是一块热点代码，于是，V8 就会将热点代码编译为优化后的二进制代码，你可以通过下面的命令来查看：

```
d8 --trace-opt-verbose test.js
```

执行这段命令之后，提示如下所示：

![image-20220814121036523](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814121036523.png)

上图中的代码优化提示：

<JSFunction foo (sfi = 0x2c730824fe21)> for optimized recompilation, reason: small function]

这就是告诉我们，已经使用 TurboFan 优化编译器将函数 foo 优化成了二进制代码，执行foo 时，实际上是执行优化过的二进制代码。

现在我们把 foo 函数中的循环加到 10 万，再来查看优化信息，最终效果如下图所示：

![image-20220814121513341](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814121513341.png)

又出现了一条新的优化信息，新的提示信息如下：

<JSFunction foo (sfi = 0xc9c0824fe21)> using TurboFan OSR]

这段提示是说，由于循环次数过多，V8 采取了 TurboFan 的 OSR 优化，OSR 全称是 On-Stack Replacement，它是一种在运行时替换正在运行的函数的栈帧的技术，如果在 foo函数中，每次调用 bar 函数时，都要创建 bar 函数的栈帧，等 bar 函数执行结束之后，又要销毁 bar 函数的栈帧。

通常情况下，这没有问题，但是在 foo 函数中，采用了大量的循环来重复调用 bar 函数，这就意味这 V8 需要不断为 bar 函数创建栈帧，销毁栈帧，那么这样势必会影响到 foo 函数的执行效率。

于是，V8 采用了 OSR 技术，将 bar 函数和 foo 函数合并成一个新的函数，具体你可以参考下图：

![image-20220814121646242](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220814121646242.png)

如果我在 foo 函数里面执行了 10 万次循环，在循环体内调用了 10 万次 bar 函数，那么V8 会实现两次优化，第一次是将 foo 函数编译成优化的二进制代码，第二次是将 foo 函数和 bar 函数合成为一个新的函数。

参考文章:on-stack replacement in v8



### 垃圾回收优化

通过 d8 来查看垃圾回收的状态，可以参看下面这段代码：

```js
function strToArray(str) {
    let i = 0
    const len = str.length
    let arr = new Uint16Array(str.length)
    for (; i < len; ++i) {
        arr[i] = str.charCodeAt(i)
    }
    return arr;
}

function foo() {
    let i = 0
    let str = 'test V8 GC'
    while (i++ < 1e5) {
        strToArray(str);
    }
}

foo()
```

上面的函数每次循环时都会生成一个数组，用于存放字符串中的每个字符。通过 trace-gc 来查看这段代码的内存回收状态，执行下面这段命令：

```
d8 --trace-gc test.js
```

打印出来的结果如下图所示：

![image-20220815125555363](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220815125555363.png)

提示内容：

```
Scavenge 1.2 (2.4) -> 0.3 (3.4) MB, 0.9 / 0.0 ms  (average mu = 1.000, current mu = 1.000) allocation failure
```

意思是提示“Scavenge … 分配失败”，是因为垃圾回收器 Scavenge 所负责的空间已经满了，Scavenge 主要回收 V8 中“新生代”中的内存，大多数对象都是分配在新生代内存中，内存分配到新生代中是非常快速的，但是新生代的空间却非常小，通常在 1～8 MB 之间，一旦空间被填满，Scavenge 就会进行“清理”操作。

上面这段代码之所以能频繁触发新生代的垃圾回收，是因为它频繁地去申请内存，而申请内存之后，这块内存就立马变得无效了，为了减少垃圾回收的频率，我们尽量避免申请不必要的内存，比如我们可以换种方式来实现上述代码，如下所示：

```js
function strToArray(str, bufferView) {
    let i = 0
    const len = str.length
    for (; i < len; ++i) {
        bufferView[i] = str.charCodeAt(i);
    }
    return bufferView;
}

function foo() {
    let i = 0
    let str = 'test V8 GC'
    let buffer = new ArrayBuffer(str.length * 2)
    let bufferView = new Uint16Array(buffer);
    while (i++ < 1e5) {
        strToArray(str,bufferView);
    }
}

foo()
```

将 strToArray 中分配的内存块，提前到了 foo 函数中分配，这样我们就不需要每次在strToArray 函数分配内存，再次执行 trace-gc 的命令：

```
d8 --trace-gc test.js
```

这时候没有任何垃圾回收的提示，这也意味着这时没有任何垃圾分配的操作。

### 内部方法

使用 V8 所提供的一些内部方法，只需要在启动 V8 时传入 allow-natives-syntax 命令，具体使用方式如下所示：

```
d8 --allow-natives-syntax test.js
```

前面的快属性和慢属性，可以通过内部方法 HasFastProperties 来检查一个对象是否拥有快属性，比如下面这
段代码：

```js
function Foo(property_num,element_num) {
    //添加可索引属性
    for (let i = 0; i < element_num; i++) {
        this[i] = `element${i}`
    }
    //添加常规属性
    for (let i = 0; i < property_num; i++) {
        let ppt = `property${i}`
        this[ppt] = ppt
    }
}
var bar = new Foo(10,10)
console.log(%HasFastProperties(bar));
delete bar.property2
console.log(%HasFastProperties(bar));
```

执行：

```
d8 test.js --allow-natives-syntax
```

通过传入 allow-natives-syntax 命令，就能使用 HasFastProperties 这一类内部接口，默认情况下，V8 中的对象都提供了快属性，不过使用了 delete bar.property2 之后，就没有快属性了，可以通过 HasFastProperties 来判断。

所以可以得出，使用 delete 时查找属性的速度就会变慢，这也是尽量不要使用 delete 的原因。

除了 HasFastProperties 方法之外，V8 提供的内部方法还有很多，比如可以使用GetHeapUsage 来查看堆的使用状态，可以使用 CollectGarbage 来主动触发垃圾回收，诸如 HaveSameMap、HasDoubleElements 等。











## 运行时环境

V8的编译流水线。

在执行 JavaScript 代码之前，V8 就已经准备好了代码的**运行时环境**，这个环境包括了 堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统。准备好运行时环境之后，V8 才可以执行 JavaScript 代码， 这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作。

![image-20220809224505358](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220809224505358.png)

### V8的宿主环境

 **V8 和浏览器的渲染进程**，浏览器的渲染进程为 V8 提供 基础的消息循环系统、全局变量、Web API，而 V8 的核心是实现了 ECMAScript 标准V8 ，V8提供了 ECMAScript 定义的一些对象和一些 核心的函数，这包括了 Object、Function、String。除此之外，V8 还提供了垃圾回收 器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行。

如果 V8 使用不当，比如不规范的代码触发了频繁的垃圾回收，或者某个函数执行时间过 久，这些都会占用宿主环境（**浏览器的渲染进程**）的主线程，从而影响到程序的执行效率，甚至导致宿主环境的卡死。

除了浏览器可以作为 V8 的宿主环境，Node.js 也是 V8 的另外一种宿主环境，它提 供了不同的宿主对象和宿主的 API，但是整个流程依然是相同的，比如 Node.js 也会提供 一套消息循环系统，也会提供一个运行时的主线程。

![image-20220810080130163](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810080130163.png)

### 宿主环境提供给V8的基础功能模块

#### 数据存储空间：堆空间和栈空间

由于 V8 是寄生在浏览器或者 Node.js 这些宿主中的，因此，V8 也是被这些宿主启动的。 比如，在 Chrome 中，只要打开一个渲染进程，渲染进程便会初始化 V8，同时初始化堆空间和栈空间。

栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构 是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比 如基本数据类型值、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个 函数执行结束，那么该函数的执行上下文便会被销毁掉。

栈空间的最大的特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查 找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误（栈提供不了这么大的空间，就抛出了栈溢出的错误）。



如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，使用栈空间就显 得不是太合适了，所以 V8 又使用了堆空间。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，在前面的课程中我们也讲 过，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览 器中还有 window 对象、document 对象等，这些都是存在堆空间的。

宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都 会存放在这两个空间中。



#### 全局执行上下文和全局作用域

V8 初始化了基础的存储空间之后，接下来就需要初始化全局执行上下文和全局作用域了， 这两个内容是 V8 执行后续流程的基础。

当 V8 开始执行一段可执行代码时，会生成一个执行上下文。V8 用执行上下文来维护执行 当前代码所需要的变量声明、this 指向等。

执行上下文中主要包含了三部分，变量环境、词法环境、和 this 关键字。比如在浏览器的 环境中，全局执行上下文中就包括了 window 对象，还有默认指向 window 的 this 关键 字，另外还有一些 Web API 函数，诸如 setTimeout、XMLHttpRequest 等内容。

而词法环境中，则包含了使用 let、const 等变量定义的内容。

执行上下文所包含的具体内容，你可以参考下图：

![image-20220810080930317](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810080930317.png)

全局执行上下文在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在 需要使用函数或者全局变量时，就不需要重新创建了。另外，当你执行了一段全局代码时， 如果全局代码中有声明的函数或者定义的变量，那么函数对象和声明的变量都会被添加到全 局执行上下文中。

在这里还有一点需要注意下，全局作用域和全局执行上下文的关系，其实你可以把作用域看 成是一个抽象的概念，比如在 ES6 中，同一个全局执行上下文中，都能存在多个作用域（块级作用域）， 可以看下面这段代码：

```js
var x = 5
{
    let y = 2
    const z = 3
}
```

这段代码在执行时，就会有两个对应的作用域，一个是全局作用域，另外一个是括号内部的 作用域，但是这些内容都会保存到全局执行上下文中。

![image-20220810081709359](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810081709359.png)



当 V8 调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函 数执行上下文就形成了一个栈结构。

#### 构造事件循环系统

**V8 还需要有一个主线程，用来执行 JavaScript 和执行垃圾回收等工 作。V8 是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程， V8 所执行的代码都是在宿主的主线程上执行的。**



**只有一个主线程依然不行，因为如果你开启一个线程，在该线程执行一段代码，那么当该线 程执行完这段代码之后，就会自动退出了，执行过程中的一些栈上的数据也随之被销毁，下 次再执行另外一个段代码时，你还需要重新启动一个线程，重新初始化栈数据，这会严重影 响到程序执行时的性能。**

为了在执行完代码之后，让线程继续运行，通常的做法是在代码中添加一个循环语句，在循 环语句中监听下个事件，比如你要执行另外一个语句，那么激活该循环就可以执行了。比如下面的模拟代码：

```js
while(1){
    Task task = GetNewTask()；
    RunTask(task)；
}
```

这段代码使用了一个循环，不同地获取新的任务，一旦有新的任务，便立即执行该任务。

如果主线程正在执行一个任务，这时候又来了一个新任务，比如 V8 正在操作 DOM，这时 候浏览器的网络线程完成了一个页面下载的任务，而且 V8 注册监听下载完成的事件，那么 这种情况下就需要引入一个消息队列，让下载完成的事件暂存到消息队列中，等当前的任务 执行结束之后，再从消息队列中取出正在排队的任务。当执行完一个任务之后，我们的事件 循环系统会重复这个过程，继续从消息队列中取出并执行下个任务。

有一点你需要注意一下，因为所有的任务都是运行在主线程的，在浏览器的页面中，V8 会 和页面共用主线程，共用消息队列，所以如果 V8 执行一个函数过久，会影响到浏览器页面 的交互性能。



## 机器代码

准备好运行时环境后，V8可以执行JS代码了。执行时，先将JS代码经过解析器解析为AST，再由解释器编译为字节码，然后再解释执行字节码，或者将需要优化的字节码编译成二进制，并直接执行二进制代码。

###  

字节码的执行模式和 CPU 直接执行二进制代码的模式是类似的。

将汇编语言编写的程序转换为机器语言的过程称为“汇编”；反之，机器语言转化 为汇编语言的过程称为“反汇编”。

一大堆指令按照顺序集合在一起就组成了程序，所以程序的执行，本质上就是 CPU 按照 顺序执行这一大堆指令的过程。



编译后的程序是由一堆二进制代码组成的，二进制代码是由一条条指 令构成的，CPU 是如何执行指令。

计算机系统的硬件组织结构：

![image-20220810131835501](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810131835501.png)

（内存、内存地址和 CPU）CPU 可以通过指定内存地址，从内存中读取数据，或者往内存中写入数据，有了内存地址，CPU 和内存就可以有序地交互。内存还是一个临时存储数据的设备，之所以是临时的存储器，是因为断电之后，内存中的数据都会消失。**内存中的每个存储空间都有其对应的独一无二的地址。**

![image-20220810132222893](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810132222893.png)

在内存中，每个存放**字节**的**空间都有其唯一的地址**，而且地址是按照顺序排放的。



![image-20220810192122002](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810192122002.png)

左侧的每一行表示一条指令，而一条指令可能占一个或者多个字节。而每个字节都有自己的内存地址。

![image-20220810192519324](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810192519324.png)

对于同一条指令，使用了相同的颜色来标记。

程序被执行过程：

1. 在程序执行之前，我们的程序需要被装进内存，比如在 Windows 下面，你可以通 过鼠标点击一个可执行文件，当你点击该文件的时候，系统中的程序加载器会将该文件加载 到内存中。
2. 二进制代码被加载进了内存后，那么内存中的每个二进制代码（一个字节）便都有了自己对应的地址
3. 二进制代码被装载进内存后，CPU 便可以从内存中取出**一条指令**，然后**分析该指令**，最后**执行该指令**。

   > 把取出指令、分析指令、执行指令这三个过程称为一个 CPU 时钟周期。当CPU执行完成一条指令之后，会立即从内存中取出下一条指令，接着分析该指令， 执行该指令，CPU 一直重复执行该过程，直至所有的指令执行完成。



### PC 寄存器

![image-20220810192838740](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810192838740.png)



CPU 中有一个 PC 寄存器，它保存了将要执行的指令地址，当二 进制代码被装载进了内存之后，系统会将二进制代码中的第一条指令的地址写入到 PC 寄存 器中，到了下一个时钟周期时，CPU 便会根据 PC 寄存器中的地址，从内存中取出指令。

PC 寄存器中的指令取出来之后，系统要做三件事：

1. 将下一条指令的地址更新到 PC 寄存器中
2. 分析该指令，并识别出不同的 类型的指令，以及各种获取操作数的方法。
3. 指令分析完成之后，就要执行指令



### 通用寄存器

了解 CPU 是如何执行指令的，我们还需要了解 CPU 中的一个重要部件：通用寄存器。

通用寄存器是 CPU 中用来存放数据的设备，不同处理器中寄存器的个数也是不一样的，之 所要通用寄存器，是因为 CPU 访问内存的速度很慢，所以 CPU 就在内部添加了一些存储 设备，这些设备就是通用寄存器。

通用寄存器容量小，读写速度快，内存容量 大，读写速度慢。

通用寄存器通常用来存放数据或者内存中某块数据的地址（指针），通 常情况下寄存器对存放的数据是没有特别的限制的，比如某个通用寄存器既可以存储数据， 也可以存储指针。

不过由于历史原因，我们还会将某些专用的数据或者指针存储在专用的通用寄存器中 ，比 如 rbp 寄存器通常用来存放栈帧指针的，rsp 寄存器用来存放栈顶指针的，PC 寄存器用来 存放下一条要执行的指令等。



### CPU 执行指令

几种常用的指令类型：

1. **加载的指令**，其作用是从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存 器中原来的内容。

   ![image-20220810194314155](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810194314155.png)

   比如上图使用了 movl 指令，指令后面跟着的第一个参数是要拷贝数据的内存的位置，第 二个参数是要拷贝到 ecx 这个寄存器。

2. 存储的指令，和加载类型的指令相反，其作用是将寄存器中的内容复制内存某个位 置，并覆盖掉内存中的这个位置上原来的内容。

   ![image-20220810194500658](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810194500658.png)

   上图也是使用 movl 指令，movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中 的地址，这条指令的作用是将寄存器中的值拷贝到内存中。

3. **更新指令**，其作用是复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和 一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中， 并覆盖该寄存器中的内容。

   ![image-20220810194609859](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810194609859.png)

   参看上图，我们可以发现 addl 指令，将寄存器 eax 和 ecx 中的值传给 ALU，ALU 对它们 进行相加操纵，并将计算的结果写回 ecx。

4. **跳转指令**，从指令本身抽取出一个字，这个字是下一条要执行 的指令的地址，并将该字复制到 PC 寄存器中，并覆盖掉 PC 寄存器中原来的值。那么当执 行下一条指令时，便会跳转到对应的指令了。
   ![image-20220810194830482](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20220810194830482.png)

   观察上图，上图是通过 jmp 来实现的，jmp 后面跟着要跳转的内存中的指令地址。

5. 有 IO 读 / 写指令，这些指令可以从一个 IO 设备中复制指定长度的 数据到寄存器中，也可以将一个寄存器中的数据复制到指定的 IO 设备。



### 汇编代码的执行流程

内存中的栈、栈帧是内存中的一块区域。





## 前端学习史

前端学习的踩坑和学习心得：

c/c++开发

之前的学习策略：遇到有关的问题才去学习相关的知识，目的是为了节省时间，结果正好相反。在遇到应用上层的问题时，一直追溯下去会有一连串环环相扣的知识，直到计算机的底层原理知识截至。

缺乏对前端整体的了解，每次遇到一些和前端相关的细节问题后，都需要花费大量时间去补充相关的知识，然后再去解决问题，这中间浪费了很多时间。

建议：在自己开发和展开一个新的技术领域时，应该将其所设计的知识做一个全方位的了解（技术栈）。先弄明白学习一门技术需要哪些知识，以及应该按照什么顺序来学习。

对于前端技术学习的技术栈：栈底到栈顶依次是浏览器架构，web网络，事件循环机制，JavaScript核心，V8内存管理，浏览器的渲染流程，Web安全，CSS，React，Vue，Node，构建工具链等，自底向上学习。

学习技术栈的每一层都不难，难的是当抛开底层栈的内容去理解上层栈的内容，那么就有可能陷入知识点的盲区。



### 建议

系统性的，循序渐进的学习一门技术，前面学到的底层知识能避免后面顶层知识出现知识盲区。这是最持续有效的一种方式。

React，Node或者Vue都是一些上层的知识（栈顶函数的上下文），不是栈底上下文知识。所谓的技术栈：是在某个领域，从底层的基础知识到上层的应用技术都包含的完整体系。

### 如何建立技术栈

对于成熟的领域，一般已经有了比较完整的技术栈资料，花些时间分析资料，系统性的了解这一个领域知识的宏观架构，过往历史和优缺点，结合现有资料和自身特点来建议自己的技术栈学习路线。







