# 计算机操作系统

## 概述

为什么要学习操作系统？

什么是操作系统？

怎样学习操作系统？

学习操作系统需要的前导知识







操作系统：

从功能来区分，有对上和对下之分。

对上的话是面向用户或者应用系统，并为他们提供服务。从用户的角度看，操作系统是一个控制程序，可以控制计算机上面的一些应用软件和程序如何运行，为不同应用程序分配系统资源。另一方面，操作系统还为应用程序提供I/O，网卡访问等一系列的能力。

对下的话给它管理的应用程序分配硬件资源，管理外设。

![image-20210808155915531](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808155915531.png)

操作系统是一种特殊的软件， 系统软件，它直接面向硬件。一般的应用程序实现的功能其实是操作系统提供的，并不是直接去访问物理资源（各种外设）。而这些外设资源是由操作系统统一协调管理，为一般应用程序提供接口API，一般应用程序方便的访问这些接口，而不用考虑底层的硬件细节。



操作系统层面的软件有两种不同的对外的接口，Shell  和 kernel 。

![image-20210808161028100](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808161028100.png)



操作系统内部细节：

- CPU
  - CPU调度
  - 进程与线程管理
- 内存
  - 物理内存管理
  - 虚拟内存管理，它主要是给上层应用提供相对独立且尽可能充足的空间去管理
- 磁盘
  - 文件系统管理
- 中断处理和I/O，设备驱动
- 网卡
- 声卡
- 显卡
- ......



操作系统的特征：

- 并发，计算机系统中同时存在多个运行的程序，需要OS管理和调度哪个程序占用CPU去运行。
  并发：**一段时间**内有多个程序可以运行。   并行：**一个时间点**上有多个程序可以运行

  能并行任务一般要求系统存在多个CPU。

  

- 共享，‘同时’共享和互斥共享

- 虚拟

- 异步

  







## CPU

关于底层细节，适度打开。

计算机需要解决的的最根本的问题：如何表示数字。

CPU最主要的运算单位：晶体管。

时钟发生器不断通过CPU的针脚给CPU芯片局部通电和断电。程序需要计算的信号内容通过针脚不断输入CPU中，以前手工输入，另一种是将数据提前写好，并存在内存中，让CPU自己去读取。

内存的本质是在内部存放一系列的电信号，而这些电信号通过总线和CPU连接，CPU将内存中的1和0读取后，在自己内部进行计算，这个计算过程需要通过时钟发生器不断的驱动它的通断电来实现。

CPU一次性能读取64位二进制数据的话就是64位CPU系统。32位同理。

CPU只认识高电频低电频（0与1），对计算机进行输入就是控制针脚的通断电。最早的计算输入是纸袋机输入。

![image-20210808140613210](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808140613210.png)

## 汇编语言

汇编的本质：机器语言的助记符，本质就是机器语言。

解释与编译：

开发者写了一个程序（C语言编写），位于硬盘上，需要执行时放在内存中，编译完的代码（.ELE，.EXE等）直接就是机器语言，CPU可以直接获取并执行。这就叫编译执行。     

对于Java程序，在内存中是字节码（ByteCode），它是不能被CPU直接执行的，在执行的过程中是读取一条指令，交给jvm翻译为机器语言再交给CPU去执行的。这就叫解释执行。JVM就是解释器。



机器语言和ByteCode都是用0101之类的表示的，  在java中ByteCode相当于java的汇编语言，因为Java跨平台。java的汇编并不和具体的某个操作系统相关，因为Java是跨平台的。所以java就设计了一种中间格式ByteCode，同一个指令由不同操作系统下的Jvm翻译都是不同的机器语言。



## CPU基本组成

![image-20210808143352892](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808143352892.png)

**PC（program counter）**：程序计数器，记录存放当前来自内存的指令在内存中的地址（这条指令位于内存中的什么位置）。CPU要执行下一条指令时，肯定需要知道下一条指令在内存中的位置。CPU执行完一条指令地址对应的指令后，会切换为下一条指令，下一条指令并不一定是指令地址数组索引加一，因为指令的长度是不固定的，得看当前指令占的字节数。

内存是一块特别大的字节数组。

**Registers**：暂时存储CPU计算需要用到的数据（寄存器数量非常多，每个寄存器都有各自的用途），将读进CPU的数据先存在寄存器中，不能放在内存中，因为太慢了，而选择放在CPU内部。

**ALU（Arithmetic & Logic Unit）**:运算单元

**CU（Control  Unit）**：控制单元，对中断信号的控制

**MMU（Memory Management Unit）**：内存管理单元

**cache**



![image-20210808151322196](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808151322196.png) 

一核多线程：即一个运算单元对应多组寄存器。平时有一个线程要运行时，该线程相关的数据放在寄存器中，指令存在程序计数器中。

如果CPU中只有一组寄存器和PC（程序计数器），在thread1运行中，thread2线程要运行，就必须将寄存器和PC中的thread1相关数据取出去放在缓存中，然后将thread2的数据放入并执行，当线程thread2的运行时间片够了，再将寄存器和PC中的thread2相关数据取出去放在缓存中，在同样的过程恢复对thread1的执行。上面的过程就叫线程切换（context switch）。 

 

<img src="C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808153332302.png" alt="image-20210808153332302" style="zoom:200%;" />







补充：

内存中的数据如何给显卡？

CPU发出指令，控制内存中的数据通过内存直接写给显卡（DMA机制），并不是说内存中的数据都需要先交给CPU，再由CPU去分发。内存中的数据发送给显卡后，显卡中的缓存区中的数据对应显示器中的像素。显示器自身有一个刷新率（60Hz，120Hz等），刷新率表述每秒从显卡中读取缓存区数据进行刷新的次数。



GPU为什么比CPU更适合做机器学习？

GPU比较纯粹，就是做一些计算然后输出到显卡，而CPU做的是通用计算，所以CPU内部的电路优化是针对通用计算和普通计算的。CPU对于人工智能所需要的哪些特殊的，大量的，计算类型不一样的计算并没有做优化。GPU正好更适合于AI的算法上的优化。

AI芯片：指的是在电路底层在设计时就设计为更适合AI计算的。



为什么要有缓存？

因为从CPU到不同的部件的速度不同。

![image-20210808153455187](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808153455187.png)

缓存的原理：

![image-20210808153641239](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808153641239.png)



![image-20210808153620913](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210808153620913.png)





CPU的乱序执行：CPU在进行读等待的同时执行指令，能提高效率。







